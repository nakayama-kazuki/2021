<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js'></script>
<canvas id='myCanvas'></canvas>
<script>

class surfacePosition {
	constructor(in_x, in_y) {
		this.setSrc(in_x, in_y);
		this.setDst(in_x, in_y);
	}
	get vector() {
		return [(this._dst.x - this._src.x) * -1, this._dst.y - this._src.y];
	}
	setSrc(in_x, in_y) {
		this._src = {
			x : in_x,
			y : in_y
		};
	}
	setDst(in_x, in_y) {
		this._dst = {
			x : in_x,
			y : in_y
		};
	}
}

class sphericalPosition {
	constructor(in_radius) {
		this._radius = in_radius;
		this._radianX = 0;
		this._radianY = 0;
	}
	_round(in_radian) {
		let radian = in_radian % (Math.PI * 2);
		return (radian > 0) ? radian : radian + (Math.PI * 2);
	}
	convVectorToXYZ(in_vector, in_updateRadian) {
		let radianX = Math.atan2(in_vector[0], this._radius);
		let radianY = Math.atan2(in_vector[1], this._radius);
		let x = Math.sin(this._radianX + radianX) * this._radius;
		let y = Math.sin(this._radianY + radianY) * this._radius;
		let z = (this._radius ** 2 - x ** 2 - y ** 2) ** 0.5;
		if (in_updateRadian) {
			this._radianX = this._round(this._radianX + radianX);
			this._radianY = this._round(this._radianY + radianY);
		}
		return [x, y, z];
	}
}

class sphericalPositionCamera {
	constructor(in_radius, in_camera) {
		this._spherical = new sphericalPosition(in_radius);
		this._camera = in_camera;
		this._setCameraPos(0, 0, in_radius);
	}
	_setCameraPos(in_x, in_y, in_z) {
		this._camera.position.set(in_x, in_y, in_z);
		this._camera.lookAt(new THREE.Vector3(0, 0, 0));
	}
	_updateCameraBySurface(in_updateRadian) {
		let vector = this._surface.vector.map(in_e => in_e * this._booster);
		let pos = this._spherical.convVectorToXYZ(vector, in_updateRadian);
		this._setCameraPos(pos[0], pos[1], pos[2]);
	}
	startMousemove(in_x, in_y, in_booster = 1) {
		this._surface = new surfacePosition(in_x, in_y);
		this._booster = in_booster;
	}
	convMousemoveToCameramove(in_x, in_y) {
		if (!this._surface) {
			return;
		}
		this._surface.setDst(in_x, in_y);
		this._updateCameraBySurface(false);
	}
	stopMousemove() {
		this._updateCameraBySurface(true);
		this._surface = null;
	}
}

const cMargin = 0.1;
const cW = window.innerWidth * (1 - cMargin);
const cH = window.innerHeight * (1 - cMargin);
const cCanvas = document.querySelector('#myCanvas');

const cRenderer = new THREE.WebGLRenderer({canvas : cCanvas});
cRenderer.setPixelRatio(window.devicePixelRatio);
cRenderer.setSize(cW, cH);

const cCamera = (in_setting => {
	return (new THREE.PerspectiveCamera(
		in_setting.fov,
		in_setting.aspect,
		in_setting.near,
		in_setting.far
	));
})({
	fov : 45,
	aspect : cW / cH,
	near : 1,
	far : 10000
});

const cContainer = (in_meshList => {
	let _container = new THREE.Object3D();
	in_meshList.forEach((in_mesh) => {
		_container.add(in_mesh);
	});
	return _container;
})([
	new THREE.Mesh(
		new THREE.BoxGeometry(300, 300, 300),
		new THREE.MeshStandardMaterial({
			color: 0x0000FF,
			side: THREE.DoubleSide
		})
	)
]);

const cLight = new THREE.AmbientLight(0xCCCCCC, 1.0);

const cScene = new THREE.Scene();
cScene.add(cContainer);
cScene.add(cLight);

(function tick() {
	cRenderer.render(cScene, cCamera);
	requestAnimationFrame(tick);
})();

const cSPC = new sphericalPositionCamera(1000, cCamera);

const listenerTable = {
	mousedown : (in_ev) => {
		let booster = 10;
		cSPC.startMousemove(in_ev.offsetX, in_ev.offsetY, booster);
	},
	mousemove : (in_ev) => {
		cSPC.convMousemoveToCameramove(in_ev.offsetX, in_ev.offsetY);
	},
	mouseup : (in_ev) => {
		cSPC.stopMousemove();
	}
};

Object.keys(listenerTable).forEach((in_key) => {
	cCanvas.addEventListener(in_key, listenerTable[in_key]);
});

</script>
