<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js'></script>
<canvas id='myCanvas'></canvas>
<script>

const cMargin = 0.1;
const cW = window.innerWidth * (1 - cMargin);
const cH = window.innerHeight * (1 - cMargin);
const cCanvas = document.querySelector('#myCanvas');

const cRenderer = new THREE.WebGLRenderer({canvas : cCanvas});
cRenderer.setPixelRatio(window.devicePixelRatio);
cRenderer.setSize(cW, cH);

const cCamera = (in_setting => {
	return (new THREE.PerspectiveCamera(
		in_setting.fov,
		in_setting.aspect,
		in_setting.near,
		in_setting.far
	));
})({
	fov : 45,
	aspect : cW / cH,
	near : 1,
	far : 10000
});

const cContainer = (in_meshList => {
	let _container = new THREE.Object3D();
	in_meshList.forEach((in_obj) => {
		_container.add(in_obj.mesh);
		in_obj.mesh.position.x = in_obj.x;
		in_obj.mesh.position.y = in_obj.y;
		in_obj.mesh.position.z = in_obj.z;
	});
	return _container;
})([
	{
		mesh : new THREE.Mesh(
			new THREE.BoxGeometry(300, 300, 300),
			new THREE.MeshStandardMaterial({
				color: 0x0000FF,
				side: THREE.DoubleSide
			})
		),
		x : 0,
		y : 0,
		z : 0
	},
	{
		mesh : new THREE.Mesh(
			new THREE.BoxGeometry(100, 100, 100),
			new THREE.MeshStandardMaterial({
				color: 0x0000FF,
				side: THREE.DoubleSide
			})
		),
		x : 250,
		y : 250,
		z : 0
	}
]);

const cLight = new THREE.AmbientLight(0xCCCCCC, 1.0);

const cScene = new THREE.Scene();
cScene.add(cContainer);
cScene.add(cLight);

(function tick() {
	cRenderer.render(cScene, cCamera);
	requestAnimationFrame(tick);
})();

class sphericalCamera {
	constructor(in_radius, in_camera) {
		this._radius = in_radius;
		this._camera = in_camera;
		this._camera.position.set(0, 0, in_radius);
		this._camera.lookAt(new THREE.Vector3(0, 0, 0));
		this._src = null;
		this._setting = {
			threshold : 5,
			movespeed : 5
		};
	}
	moveCameraRectangular(in_x, in_y) {
		let delta = (new THREE.Vector2(in_x, in_y)).sub(this._src);
		if (delta.length() < this._setting.threshold) {
			return;
		}
		let the = delta.x / this._radius * this._setting.movespeed * -1;
		let phi = delta.y / this._radius * this._setting.movespeed * -1;
		this.moveCameraPolar(the, phi);
		this._src = new THREE.Vector2(in_x, in_y);
	}
	moveCameraPolar(in_the, in_phi) {
		let spherical = new THREE.Spherical();
		spherical.setFromVector3(this._camera.position);
		spherical.theta += in_the;
		spherical.phi -= in_phi;
		spherical.makeSafe();
		this._camera.position.setFromSpherical(spherical); 
		this._camera.lookAt(new THREE.Vector3(0, 0, 0));
	}
	attachListener(in_elem) {
		const eventList = ['mousedown', 'mousemove', 'mouseup'];
		eventList.forEach((in_event_name) => {
			let listener = ((in_self) => {
				let invertAxis = -1;
				let method = '_' + in_event_name;
				return (in_ev) => {
					(in_self[method])(in_ev.offsetX, in_ev.offsetY * invertAxis);
				}
			})(this);
			(in_elem).addEventListener(in_event_name, listener);
		});
	}
	_mousedown(in_x, in_y) {
		this._src = new THREE.Vector2(in_x, in_y);
	}
	_mousemove(in_x, in_y) {
		if (!this._src) {
			return;
		}
		this.moveCameraRectangular(in_x, in_y);
	}
	_mouseup(in_x, in_y) {
		this.moveCameraRectangular(in_x, in_y);
		this._src = null;
	}
}

const cSC = new sphericalCamera(1000, cCamera);
cSC.attachListener(cCanvas);

</script>
